#include "main.h"
#include "MemoryBuffer.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h>

/* global variables */
GLOBALPROP g_gprop = {0};


void trim( char* line )
{
	int i = 0, j = 0;
	if ( !line ) return;
	
	for ( i = strlen(line)-1; i >= 0 && isspace(line[i]); --i );
	line[i+1] = '\0';
	for( i = 0; isspace(line[i]); ++i );
	if ( i > 0 ) {
		while ( line[i] != '\0' ) { line[j++] = line[i++]; }
		line[j] = '\0';
	}
}

void delete_comment( char *line )
{
	if ( !line ) return;
	
	while ( *line != '\0' ) {
		if ( *line == '#' ) {
			*line = '\0';
			break;
		} else if ( *line == '\"' ) {
			while ( *line != '\"' && *line != '\0' ) line++;
		}
		line++;
	}
}

void strip( char *line )
{
	if ( !line ) return;
	
	delete_comment(line);
	trim(line);
}


bool get_nibble( const char c, uint8_t &nibble )
{
	bool ret = true;
	switch ( c )
	{
	case '0': nibble = 0x0; break;
	case '1': nibble = 0x1; break;
	case '2': nibble = 0x2; break;
	case '3': nibble = 0x3; break;
	case '4': nibble = 0x4; break;
	case '5': nibble = 0x5; break;
	case '6': nibble = 0x6; break;
	case '7': nibble = 0x7; break;
	case '8': nibble = 0x8; break;
	case '9': nibble = 0x9; break;
	case 'a': 
	case 'A': nibble = 0xA; break;
	case 'b': 
	case 'B': nibble = 0xB; break;
	case 'c': 
	case 'C': nibble = 0xC; break;
	case 'd': 
	case 'D': nibble = 0xD; break;
	case 'e': 
	case 'E': nibble = 0xE; break;
	case 'f': 
	case 'F': nibble = 0xF; break;
	default: 
		ret = false; 
		break;
	}
	return ret;
}

void packbin( const char *fname_in, const char *fname_out )
{
	FILE *infp = NULL, *outfp = NULL;
	char line[1024] = "";
	
	infp = fopen(fname_in, "r");
	if ( !infp ) {
		fprintf(stderr, "could not open %s\n", fname_in);
		return;
	}
	
	outfp = fopen(fname_out, "w");
	if ( !infp ) {
		fprintf(stderr, "could not open %s\n", fname_out);
		return;
	}
	
	while ( fgets(line, sizeof(line), infp) )
	{
		strip(line);
		if ( strcasecmp(line, "DUMP START") == 0 ) {
			fprintf(stderr, "found [DUMP START]\n");
			break;
		}
	}
	while ( fgets(line, sizeof(line), infp) )
	{
		strip(line);
		if ( strcasecmp(line, "DUMP END") == 0 ) {
			fprintf(stderr, "found [DUMP END]\n");
			break;
		}
		
		char *line_ptr = line;
		uint8_t octet = 0, nibble = 0;
		bool first_flag = true;
		
		while ( *line_ptr != '\0' ) {
			if ( get_nibble(*line_ptr, nibble) ) {
				if ( first_flag ) {
					octet = nibble << 4;
				} else {
					octet |= nibble & 0xF;
					fwrite(&octet, sizeof(uint8_t), 1, outfp);
				}
				first_flag = !first_flag;
			}
			line_ptr++;
		}
	}
	
	fclose(infp);
	fclose(outfp);
}

void packbin2( const char *fname_in, const char *fname_out )
{
	FILE *infp = NULL, *outfp = NULL;
	char line[1024] = "";
	MemoryBuffer buffer;
	
	infp = fopen(fname_in, "r");
	if ( !infp ) {
		fprintf(stderr, "could not open %s\n", fname_in);
		return;
	}
	
	outfp = fopen(fname_out, "w");
	if ( !infp ) {
		fprintf(stderr, "could not open %s\n", fname_out);
		return;
	}
	
	while ( fgets(line, sizeof(line), infp) )
	{
		strip(line);
		if ( strcasecmp(line, "DUMP START") == 0 ) {
			fprintf(stderr, "found [DUMP START]\n");
			break;
		}
	}
	while ( fgets(line, sizeof(line), infp) )
	{
		strip(line);
		if ( strcasecmp(line, "DUMP END") == 0 ) {
			fprintf(stderr, "found [DUMP END]\n");
			break;
		}
		
		char *line_ptr = line;
		uint8_t octet = 0, nibble = 0;
		bool first_flag = true;
		
		while ( *line_ptr != '\0' ) {
			if ( get_nibble(*line_ptr, nibble) ) {
				if ( first_flag ) {
					octet = nibble << 4;
				} else {
					octet |= nibble & 0xF;
					buffer.add(&octet, sizeof(uint8_t));
				}
				first_flag = !first_flag;
			}
			line_ptr++;
		}
	}
	
	fprintf(stderr, "pack size: %lu\n", buffer.len());
	fwrite(buffer.ptr(), sizeof(uint8_t), buffer.len(), outfp);
	
	fclose(infp);
	fclose(outfp);
}

//--------------------------------------------------------------
// show usage
//--------------------------------------------------------------
void usage(void)
{
	printf("[ %s Version %s ]\n", MODULENAME_STRING, VERSION_STRING);
	printf("pack hex dump text which is generated by dumpbin.\n");
	printf("\n");
	printf("Usage : %s [option...] <file1> <file2>\n", MODULENAME_STRING);
	printf("        <file1>    : hex dump text file.\n");
	printf("        <file2>    : output path.\n");
	printf("\n");
}


//--------------------------------------------------------------
// parse command line
//--------------------------------------------------------------
bool parse_cmdline( int argc, char **argv )
{
	bool ret = true;
	char *s = NULL;

	/* initialize */
	g_gprop.file1 = NULL;
	g_gprop.file2 = NULL;
	
	/* parse */
	while ( --argc > 0 ) {
		s = *++argv;
		if ( *s == '-' ) {
			switch ( *++s )
			{
			case 'h':
			case '?':
				usage();
				ret = false;
				break;
			default:
				fprintf(stderr, "Unknown parameter : -%s\n", s);
				ret = false;
				break;
			}
		}
		else {
			if ( !g_gprop.file1 ) g_gprop.file1 = s;
			else if ( !g_gprop.file2 ) g_gprop.file2 = s;
		}
	}

	return ret;
}


int main( int argc, char **argv )
{
	if ( !parse_cmdline(argc, argv) ) {
		return -1;
	}
	
	if ( !prop()->file1 || !prop()->file2 ) {
		fprintf(stderr, "too few arguments.\n");
		return -1;
	}
	
	packbin2( prop()->file1, prop()->file2 );
	
	return 0;
}

